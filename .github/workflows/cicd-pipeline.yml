name: CI/CD Pipeline Completo

env:
  JAVA_VERSION: '21'

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, closed]
    branches:
      - main
      - master
      - develop
      - 'release/*'
      - 'hotfix/*'
  push:
    branches:
      - main
      - master
  schedule:
    - cron: "0 0 * * 1" # Para CodeQL
    - cron: '20 7 * * 2' # Para Scorecard
  branch_protection_rule: # Para Scorecard

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.sha }}
  cancel-in-progress: true

jobs:
  validate_pr:
    name: AI Review & Build PR
    if: github.event.action != 'closed' && github.event.action != 'labeled'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      checks: write

    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2.12.0
        with:
          egress-policy: audit

      - name: Checkout Code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Prepare for AI Review
        id: prepare_ai_review
        run: |
          DIFF=$(git diff ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head_sha }})
          if [ -z "$DIFF" ] || [ ${#DIFF} -lt 50 ]; then
            echo "Warning: Diff is empty or too small, skipping AI review."
            echo "should_run=false" >> $GITHUB_OUTPUT
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "$DIFF" > diff.txt
          fi

      - name: Generate AI summary
        id: generate_summary
        if: steps.prepare_ai_review.outputs.should_run == 'true'
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
        run: |
          ESCAPED_DIFF=$(jq -Rs . < diff.txt)
          cat > payload.json <<EOF
          {
            "model": "openai/gpt-4o",
            "messages": [
              { "role": "system", "content": "Você é um engenheiro de software sênior. Sua tarefa é analisar o diff de código a seguir e gerar um resumo técnico em formato markdown para a descrição de um Pull Request. **Comece diretamente com os pontos de análise, sem adicionar um título próprio como 'Resumo da Pull Request'.** O resumo deve ser conciso e focar nos seguintes pontos: 1. **Propósito da Mudança**; 2. **Principais Alterações Técnicas** (classes, métodos, lógica); 3. **Possíveis Impactos ou Riscos**. A resposta deve ser em PORTUGUÊS BRASILEIRO e em formato markdown puro, sem envolvê-la em blocos de código." },
              { "role": "user", "content": $ESCAPED_DIFF }
            ]
          }
          EOF
          HTTP_RESPONSE=$(curl -s -w "%{http_code}" -X POST https://openrouter.ai/api/v1/chat/completions -H "Content-Type: application/json" -H "Authorization: Bearer $OPENROUTER_API_KEY" --data-binary @payload.json -o response.json -m 90)
          if [ "$HTTP_RESPONSE" -ge 400 ]; then
             echo "Error: API call failed with status code $HTTP_RESPONSE."
             cat response.json
             exit 1
          fi
          SUMMARY=$(jq -r '.choices[0].message.content // ""' < response.json)
          if [ -z "$SUMMARY" ]; then
            SUMMARY="### Análise da IA\n\nA IA não conseguiu gerar uma análise para estas alterações."
          fi
          echo "$SUMMARY" > summary.md
          echo "has_summary=true" >> $GITHUB_OUTPUT

      - name: Update PR title and description with AI summary
        if: steps.generate_summary.outputs.has_summary == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const summary = fs.readFileSync('summary.md', 'utf8');
            if (!summary.trim()) { return; }
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });
            
            // --- Lógica para o Corpo da PR (Description) ---
            const oldBody = pr.body || '';
            const markerStart = '### Análise Automática da IA';
            const markerEnd = '---';
            const startIndex = oldBody.indexOf(markerStart);
            let cleanBody = oldBody;
            if (startIndex !== -1) {
              const endIndex = oldBody.indexOf(markerEnd, startIndex);
              cleanBody = (endIndex !== -1) ? oldBody.substring(0, startIndex) + oldBody.substring(endIndex + markerEnd.length) : oldBody.substring(0, startIndex);
            }
            const newBody = `${markerStart}\n\n${summary}\n\n${markerEnd}\n${cleanBody.trim()}`.trim();

            // --- Lógica para o Título da PR (Title) ---
            let newTitle = pr.title;
            const titleMatch = summary.match(/^\s*(?:\d+\.|\*)\s*(.+)/m);
            if (titleMatch && titleMatch[1]) {
                const summaryTitle = titleMatch[1].trim().replace(/\.$/, ''); 
            
                if (!pr.title.toLowerCase().includes('update')) {
                   newTitle = summaryTitle; 
                } else {
                   newTitle = summaryTitle;
                }
            }
            
            await github.rest.pulls.update({ owner, repo, pull_number, body: newBody, title: newTitle });

      - name: Set up Java
        uses: actions/setup-java@v5
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'

      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      - name: Use Gradle Cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Build and test with Gradle wrapper
        run: |
          chmod +x gradlew
          ./gradlew clean build test jacocoTestReport --no-daemon

      - name: Publish Test Results
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          check_name: Test Results
          junit_files: '**/build/test-results/**/*.xml'

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        with:
          slug: ${{ github.repository }}

      - name: Upload test results to Codecov
        if: ${{ !cancelled() }}
        uses: codecov/test-results-action@v1
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  dependency_review:
    name: Dependency Review
    if: github.event.action != 'closed' && github.event.action != 'labeled'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2.12.0
        with:
          egress-policy: audit
      - name: 'Checkout Repository'
        uses: actions/checkout@v5
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@v4

  codeql_analysis:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        language: ["java"]
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2.12.0
        with:
          egress-policy: audit
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}
      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:${{matrix.language}}"

  scorecard_analysis:
    name: Scorecard Analysis
    if: github.event_name == 'branch_protection_rule' || github.event_name == 'schedule' || (github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'))
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      id-token: write
      contents: read
      actions: read
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@v2.12.0
        with:
          egress-policy: audit
      - name: "Checkout code"
        uses: actions/checkout@v5
        with:
          persist-credentials: false
      - name: "Run analysis"
        uses: ossf/scorecard-action@v2.4.0
        with:
          results_file: results.sarif
          results_format: sarif
          publish_results: true
      - name: "Upload artifact"
        uses: actions/upload-artifact@v5
        with:
          name: SARIF file
          path: results.sarif
          retention-days: 5
      - name: "Upload to code-scanning"
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: results.sarif

  prepare_minor_release:
    name: Prepare Minor Release Branch (MINOR)
    if: >
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'develop' &&
      contains(github.event.pull_request.labels.*.name, 'create-release') &&
      !contains(github.event.pull_request.labels.*.name, 'create-major-release')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout develop branch
        uses: actions/checkout@v5
        with:
          ref: 'develop'
          fetch-depth: 0
      - name: Configure Git User
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      - name: Calculate and Create New MINOR Release Branch
        run: |
          git fetch --prune --tags
          LAST_TAG=$(git tag -l "v*.*.*" --sort=-v:refname | head -n 1)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="v0.0.0"
          fi
          echo "Last tag: $LAST_TAG"
          LAST_TAG_NUM=${LAST_TAG#v}
          IFS='.' read -r -a V <<< "$LAST_TAG_NUM"
          # Incrementa o MINOR e reseta o PATCH
          V[1]=$((V[1] + 1))
          V[2]=0
          NEW_VERSION="v${V[0]}.${V[1]}.${V[2]}"
          BRANCH_NAME="release/$NEW_VERSION"
          echo "Creating new branch from develop: $BRANCH_NAME"
          git checkout -b $BRANCH_NAME
          git push origin $BRANCH_NAME

      - name: Delete Merged Feature Branch
        run: |
          SOURCE_BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "Deleting merged feature branch: $SOURCE_BRANCH"
          git push origin --delete $SOURCE_BRANCH

  prepare_major_release:
    name: Prepare Major Release Branch (MAJOR)
    if: >
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'develop' &&
      contains(github.event.pull_request.labels.*.name, 'create-major-release')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout develop branch
        uses: actions/checkout@v5
        with:
          ref: 'develop'
          fetch-depth: 0
      - name: Configure Git User
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      - name: Calculate and Create New MAJOR Release Branch
        run: |
          git fetch --prune --tags
          LAST_TAG=$(git tag -l "v*.*.*" --sort=-v:refname | head -n 1)
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="v0.0.0"
          fi
          echo "Last tag: $LAST_TAG"
          LAST_TAG_NUM=${LAST_TAG#v}
          IFS='.' read -r -a V <<< "$LAST_TAG_NUM"
          
          # --- LÓGICA PARA INCREMENTAR O MAJOR ---
          V[0]=$((V[0] + 1)) 
          V[1]=0             
          V[2]=0            
          NEW_VERSION="v${V[0]}.${V[1]}.${V[2]}"
          # ----------------------------------------
          
          BRANCH_NAME="release/$NEW_VERSION"
          echo "Creating new branch from develop: $BRANCH_NAME"
          git checkout -b $BRANCH_NAME
          git push origin $BRANCH_NAME

      - name: Delete Merged Feature Branch
        run: |
          SOURCE_BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "Deleting merged feature branch: $SOURCE_BRANCH"
          git push origin --delete $SOURCE_BRANCH

  finalize_release:
    name: Tag Release & Sync Develop
    if: >
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'master')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
      tagged: ${{ steps.create_tag.outputs.should_run }}
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v5
        with:
          ref: 'main'
          fetch-depth: 0
      - name: Configure Git User
        run: |
          git config user.name "GitHub Actions Bot"
          git config user.email "github-actions[bot]@users.noreply.github.com"
      - name: Create and Push Gitflow Tag
        id: create_tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SOURCE_BRANCH="${{ github.event.pull_request.head.ref }}"
          NEW_TAG=""
          echo "Source branch for merge to main is: $SOURCE_BRANCH"
          
          if [[ "$SOURCE_BRANCH" == "release/"* ]]; then
            NEW_TAG=$(echo $SOURCE_BRANCH | sed 's/release\///')
            echo "Release branch merge. Tag will be: $NEW_TAG"
          elif [[ "$SOURCE_BRANCH" == "hotfix/"* ]]; then
            LAST_TAG=$(git tag -l "v*.*.*" --sort=-v:refname | head -n 1)
            LAST_TAG_NUM=${LAST_TAG#v}
            IFS='.' read -r -a V <<< "$LAST_TAG_NUM"
            V[2]=$((V[2] + 1))
            NEW_TAG="v${V[0]}.${V[1]}.${V[2]}"
            echo "Hotfix branch merge. New patch tag will be: $NEW_TAG"
          else
            echo "Merge to main is not from a release/hotfix branch. Skipping."
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "new_tag=none" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          git tag $NEW_TAG ${{ github.event.pull_request.merge_commit_sha }}
          git push origin $NEW_TAG
          echo "Tag $NEW_TAG created and pushed."
          echo "should_run=true" >> $GITHUB_OUTPUT
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Sync main back to develop
        if: steps.create_tag.outputs.should_run == 'true'
        run: |
          echo "Syncing main back into develop..."
          git fetch origin develop
          git checkout develop
          git merge origin/main --no-ff -m "chore: sync main after release [skip ci]"
          git push origin develop
          echo "Develop branch is now up-to-date with main."

      - name: Delete Merged Release or Hotfix Branch
        if: steps.create_tag.outputs.should_run == 'true'
        run: |
          SOURCE_BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "Deleting merged release/hotfix branch: $SOURCE_BRANCH"
          git push origin --delete $SOURCE_BRANCH

  deploy_to_jenkins:
    name: Deploy to Jenkins
    runs-on: ubuntu-latest
    needs: finalize_release
    if: needs.finalize_release.result == 'success' && needs.finalize_release.outputs.tagged == 'true'
    steps:
      - name: "Deploy to Jenkins"
        run: |
          echo "Triggering Jenkins deploy for tag: ${{ needs.finalize_release.outputs.new_tag }}"
          # Você pode passar a tag para o Jenkins, se ele aceitar:
          # &NEW_TAG=${{ needs.finalize_release.outputs.new_tag }}
          curl -X POST "${{ secrets.JENKINS_URL }}/job/${{ secrets.JENKINS_JOB }}/buildWithParameters?PROJECT=${{ secrets.JENKINS_PROJECT }}&GIT_BRANCH=main" \
          --user "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}"